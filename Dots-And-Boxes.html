<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dots and Boxes 10×10 — Player vs IA</title>
<style>
  :root{
    --dot:10px; --gap:36px; --edge:36px; --thick:10px; --box:36px;
    --bg:#0d1117; --fg:#c9d1d9; --grid:#30363d; --hover:#3d444d;
    --p:#2ea043; --a:#58a6ff; --pbg:#15361f; --abg:#0f2a44;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,Arial,sans-serif; background:var(--bg); color:var(--fg);}
  header{display:flex; gap:12px; align-items:center; padding:10px 14px; border-bottom:1px solid #21262d;}
  .pill{padding:4px 10px; border:1px solid #30363d; border-radius:999px; font-size:14px}
  .pill.p{border-color:var(--p); color:var(--p)}
  .pill.a{border-color:var(--a); color:var(--a)}
  #turn{margin-left:auto; opacity:.9}
  #restart{margin-left:8px; padding:6px 10px; border:1px solid #30363d; background:#161b22; color:var(--fg); border-radius:8px; cursor:pointer}
  #restart:hover{background:#1b2330}
  .wrap{padding:12px}
  .board-wrap{overflow:auto; border:1px solid #21262d; border-radius:12px; padding:10px; background:#0b1117; max-width:100vw}
  .board{position:relative; width: calc(9*var(--gap) + 10*var(--dot)); height: calc(9*var(--gap) + 10*var(--dot));}
  .dot{position:absolute; width:var(--dot); height:var(--dot); background:#e6edf3; border-radius:50%; transform:translate(-50%,-50%)}
  .edge{position:absolute; background:var(--grid); border-radius:6px; cursor:pointer; transition:filter .12s, background .12s}
  .edge.h{width:var(--edge); height:var(--thick); transform:translate(-50%,-50%)}
  .edge.v{width:var(--thick); height:var(--edge); transform:translate(-50%,-50%)}
  .edge.free:hover{background:var(--hover); filter:brightness(1.05)}
  .edge.p{background:var(--p)}
  .edge.a{background:var(--a)}
  .box{position:absolute; width:var(--box); height:var(--box); transform:translate(-50%,-50%); border-radius:6px; display:flex; align-items:center; justify-content:center; font-size:12px; color:#9fb; }
  .box.p{background:var(--pbg); outline:1px solid rgba(46,160,67,.4)}
  .box.a{background:var(--abg); outline:1px solid rgba(88,166,255,.35); color:#bcd8ff}
  footer{padding:10px 14px; border-top:1px solid #21262d; font-size:13px; opacity:.8}
</style>
</head>
<body>
<header>
  <span class="pill p">Player: <b id="scoreP">0</b></span>
  <span class="pill a">IA: <b id="scoreA">0</b></span>
  <span id="turn">Vez: Player</span>
  <button id="restart" title="Reiniciar">↻ Reiniciar</button>
</header>

<div class="wrap">
  <div class="board-wrap">
    <div class="board" id="board"></div>
  </div>
</div>

<footer>Regra: fechou quadrado = ponto e joga de novo.</footer>

<script>
(() => {
  // ---------- Config ----------
  const N = 10;                 // pontos por lado -> caixas 9x9
  const DOT = 10, GAP = 36;     // layout
  const boardEl = document.getElementById('board');
  const scorePEl = document.getElementById('scoreP');
  const scoreAEl = document.getElementById('scoreA');
  const turnEl  = document.getElementById('turn');
  const restartBtn = document.getElementById('restart');

  // ---------- Estado ----------
  let h, v, box, scoreP, scoreA, current; // h[N][N-1], v[N-1][N], box[N-1][N-1]; 0 livre, 1 P, 2 A
  let edgeEls; // Map key -> element

  restartBtn.onclick = () => init();

  init();

  function init(){
    h = Array.from({length:N}, () => Array(N-1).fill(0));
    v = Array.from({length:N-1}, () => Array(N).fill(0));
    box = Array.from({length:N-1}, () => Array(N-1).fill(0));
    scoreP = 0; scoreA = 0;
    current = 1; // 1=Player, 2=IA
    updateScore(); turnEl.textContent = 'Vez: Player';
    render();
  }

  // ---------- Render ----------
  function render(){
    boardEl.innerHTML = '';
    edgeEls = new Map();

    // dots
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const d = document.createElement('div');
        d.className = 'dot';
        d.style.left = (c*GAP + DOT) + 'px';
        d.style.top  = (r*GAP + DOT) + 'px';
        boardEl.appendChild(d);
      }
    }
    // horizontal edges
    for(let r=0;r<N;r++){
      for(let c=0;c<N-1;c++){
        const e = document.createElement('div');
        e.className = 'edge h ' + (h[r][c]===0?'free':(h[r][c]===1?'p':'a'));
        e.style.left = (c*GAP + DOT + GAP/2) + 'px';
        e.style.top  = (r*GAP + DOT) + 'px';
        const key = `h,${r},${c}`;
        edgeEls.set(key, e);
        if(h[r][c]===0) e.onclick = () => handleClick('h', r, c);
        boardEl.appendChild(e);
      }
    }
    // vertical edges
    for(let r=0;r<N-1;r++){
      for(let c=0;c<N;c++){
        const e = document.createElement('div');
        e.className = 'edge v ' + (v[r][c]===0?'free':(v[r][c]===1?'p':'a'));
        e.style.left = (c*GAP + DOT) + 'px';
        e.style.top  = (r*GAP + DOT + GAP/2) + 'px';
        const key = `v,${r},${c}`;
        edgeEls.set(key, e);
        if(v[r][c]===0) e.onclick = () => handleClick('v', r, c);
        boardEl.appendChild(e);
      }
    }
    // boxes
    for(let r=0;r<N-1;r++){
      for(let c=0;c<N-1;c++){
        if(box[r][c]!==0){
          const b = document.createElement('div');
          b.className = 'box ' + (box[r][c]===1?'p':'a');
          b.style.left = (c*GAP + DOT + GAP/2) + 'px';
          b.style.top  = (r*GAP + DOT + GAP/2) + 'px';
          boardEl.appendChild(b);
        }
      }
    }
  }

  function updateScore(){
    scorePEl.textContent = scoreP;
    scoreAEl.textContent = scoreA;
  }

  // ---------- Util ----------
  function countSides(st, br, bc){
    let cnt = 0;
    if (st.h[br][bc]) cnt++;
    if (st.h[br+1][bc]) cnt++;
    if (st.v[br][bc]) cnt++;
    if (st.v[br][bc+1]) cnt++;
    return cnt;
  }
  function missingEdge(st, br, bc){
    if (!st.h[br][bc]) return ['h', br, bc];
    if (!st.h[br+1][bc]) return ['h', br+1, bc];
    if (!st.v[br][bc]) return ['v', br, bc];
    if (!st.v[br][bc+1]) return ['v', br, bc+1];
    return null;
  }
  function playable(){
    const list=[];
    for(let r=0;r<N;r++) for(let c=0;c<N-1;c++) if(!h[r][c]) list.push(['h',r,c]);
    for(let r=0;r<N-1;r++) for(let c=0;c<N;c++) if(!v[r][c]) list.push(['v',r,c]);
    return list;
  }
  function adjBoxes(t,r,c){
    const res=[];
    if(t==='h'){
      if (r-1>=0 && r-1<N-1) res.push([r-1,c]);
      if (r>=0   && r<N-1)   res.push([r,c]);
    }else{
      if (c-1>=0 && c-1<N-1) res.push([r,c-1]);
      if (c>=0   && c<N-1)   res.push([r,c]);
    }
    return res;
  }
  function createsThirdSide(t,r,c){
    for(const [br,bc] of adjBoxes(t,r,c)){
      const cnt = countSides({h,v}, br, bc);
      if (cnt===2) return true;
    }
    return false;
  }

  // ---------- Aplicação de jogada real ----------
  function applyEdgeReal(t,r,c, owner){ // owner: 1 P, 2 A
    if (t==='h') h[r][c]=owner; else v[r][c]=owner;
    let made=0;
    for(const [br,bc] of adjBoxes(t,r,c)){
      if (countSides({h,v}, br, bc)===4 && box[br][bc]===0){
        box[br][bc]=owner; made++;
      }
    }
    if (owner===1) scoreP+=made; else scoreA+=made;
    return made;
  }

  // ---------- Simulações ----------
  function cloneState(){
    return {
      h: h.map(row=>row.slice()),
      v: v.map(row=>row.slice()),
      box: box.map(row=>row.slice())
    };
  }
  function applyEdgeSim(st, t,r,c, owner){ // altera st, retorna capturas
    if (t==='h') st.h[r][c]=owner; else st.v[r][c]=owner;
    let made=0;
    const N1=N-1;
    for(const [br,bc] of (t==='h'?[ [r-1,c],[r,c] ]:[ [r,c-1],[r,c] ])){
      if (br>=0 && br<N1 && bc>=0 && bc<N1){
        if (countSides(st, br, bc)===4 && st.box[br][bc]===0){
          st.box[br][bc]=owner; made++;
        }
      }
    }
    return made;
  }
  function forcedCaptureCountIfWePlay(t,r,c){
    const st = cloneState();
    applyEdgeSim(st, t,r,c, 2); // IA joga
    // agora oponente fecha todas caixas de 3 lados enquanto existirem
    let gained=0, progress=true;
    while(progress){
      progress=false;
      for(let br=0;br<N-1;br++){
        for(let bc=0;bc<N-1;bc++){
          if (st.box[br][bc]===0 && countSides(st, br, bc)===3){
            const [mt,mr,mc] = missingEdge(st, br, bc);
            gained += applyEdgeSim(st, mt,mr,mc, 1); // player
            progress=true;
          }
        }
      }
    }
    return gained;
  }

  // ---------- Fluxo ----------
  function handleClick(t,r,c){
    if (current!==1) return; // vez da IA
    if (t==='h' ? h[r][c] : v[r][c]) return;

    const made = applyEdgeReal(t,r,c,1);
    render(); updateScore();

    if (isFinished()){ finish(); return; }

    if (made>0){ // player mantém a vez
      turnEl.textContent = 'Vez: Player';
      return;
    }
    current = 2;
    turnEl.textContent = 'Vez: IA';
    setTimeout(aiTurn, 120);
  }

  function isFinished(){
    for(let r=0;r<N;r++) for(let c=0;c<N-1;c++) if(!h[r][c]) return false;
    for(let r=0;r<N-1;r++) for(let c=0;c<N;c++) if(!v[r][c]) return false;
    return true;
  }

  function finish(){
    const msg = scoreP>scoreA ? 'Você venceu.' : (scoreA>scoreP ? 'IA venceu.' : 'Empate.');
    turnEl.textContent = `Fim — ${msg} (${scoreP}×${scoreA})`;
  }

  // ---------- IA forte (heurística de cadeias) ----------
  function aiTurn(){
    if (isFinished()){ finish(); return; }

    // 1) Capturas forçadas: enquanto existir caixa com 3 lados, capture e continue
    let moved=true;
    while(moved){
      moved=false;
      const cap = findCaptureMove();
      if (cap){
        const made = applyEdgeReal(...cap, 2);
        moved = made>0;
      }
    }
    render(); updateScore();
    if (isFinished()){ finish(); return; }

    // 2) Se não há capturas: procurar jogadas seguras (não criam 3º lado)
    const safeMoves = [];
    for (const e of playable()){
      if (!createsThirdSide(...e)) safeMoves.push(e);
    }
    if (safeMoves.length){
      // Heurística: preferir bordas e caixas com menos lados
      safeMoves.sort((a,b)=> safetyScore(b) - safetyScore(a));
      const [t,r,c] = safeMoves[0];
      const made = applyEdgeReal(t,r,c,2);
      render(); updateScore();
      if (made>0){ setTimeout(aiTurn, 80); return; } // mantém a vez
      current = 1; turnEl.textContent='Vez: Player'; return;
    }

    // 3) Forçado: escolher a jogada que minimiza a corrente entregue ao jogador
    let best=null, bestPun=Infinity;
    for (const e of playable()){
      const pun = forcedCaptureCountIfWePlay(...e);
      if (pun < bestPun){ bestPun=pun; best=e; }
    }
    if (best){
      const made = applyEdgeReal(...best, 2);
      render(); updateScore();
      if (made>0){ setTimeout(aiTurn, 80); return; }
    }
    current = 1; turnEl.textContent='Vez: Player';
  }

  function findCaptureMove(){
    for (const [t,r,c] of playable()){
      const adj = adjBoxes(t,r,c);
      for (const [br,bc] of adj){
        if (countSides({h,v}, br, bc)===3) return [t,r,c];
      }
    }
    return null;
  }

  function safetyScore(e){
    let s=0;
    for (const [br,bc] of adjBoxes(...e)){
      const cnt = countSides({h,v}, br, bc);
      if (cnt===0) s+=3;
      else if (cnt===1) s+=1;
      // leve bônus borda
      if (br===0||bc===0||br===N-2||bc===N-2) s+=0.2;
    }
    return s;
  }
})();
</script>
</body>
</html>